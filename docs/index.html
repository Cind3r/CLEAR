<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Hospital Price Finder (ZIP Radius + Procedure)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <!-- Mobile device detection and redirect -->
  <script>
    (function() {
      // Check if user is on mobile device
      const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
      const isSmallScreen = window.innerWidth <= 768;
      const hasTouch = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
      
      // Redirect to mobile version if mobile device detected
      if ((isMobile || (isSmallScreen && hasTouch)) && !window.location.search.includes('desktop=1')) {
        window.location.href = 'index-mobile.html';
      }
    })();
  </script>
  <!-- d3 as global (ok inside module) -->
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <style>
  :root{--bg:#0f172a;--ink:#e2e8f0;--muted:#9aa6b2;}
  *{box-sizing:border-box}
  body{margin:0;background:var(--bg);color:var(--ink);font:14px system-ui,Segoe UI,Roboto,Helvetica,Arial}
  header{position:sticky;top:0;z-index:10;display:flex;gap:.5rem;align-items:center;padding:.6rem .8rem;background:rgba(15,23,42,.95);backdrop-filter:blur(8px);flex-wrap:wrap}
  input,select,button{background:#111827;color:var(--ink);border:1px solid #1f2937;border-radius:.5rem;padding:.45rem .55rem}
  label{display:flex;align-items:center;gap:.35rem}
  button{cursor:pointer}
  #status{color:var(--muted);font-size:12px}
  main{display:flex;height:calc(100vh - 56px)}
  .map-container{flex:1;display:flex;flex-direction:column;position:relative}
  svg{display:block;width:100%;height:100%}
  .reset-zoom-btn{position:absolute;bottom:1rem;left:1rem;background:#1f2937;color:var(--ink);border:1px solid #374151;border-radius:.5rem;padding:.5rem .75rem;cursor:pointer;font-size:12px;z-index:5;transition:all 0.2s ease}
  .reset-zoom-btn:hover{background:#374151;border-color:#4b5563}
  aside{border-left:1px solid #1f2937;width:360px;height:100%;overflow:auto;padding:.6rem}
  .visualization-section{border-top:1px solid #1f2937;padding:.8rem;height:70vh}
  .viz-container{display:grid;grid-template-columns:1fr 1fr;gap:1rem;height:100%}
  .viz-panel{border:1px solid #1f2937;border-radius:.6rem;padding:.6rem;background:#0b1325}
  .info-section{border-top:1px solid #1f2937;padding:2rem;background:#0a0f1c}
  .info-container{max-width:1000px;margin:0 auto;line-height:1.6}
  .info-section h2{color:#e2e8f0;font-size:24px;margin-bottom:1rem;text-align:center}
  .info-section h3{color:#cbd5e1;font-size:18px;margin:1.5rem 0 .75rem;display:flex;align-items:center;gap:.5rem}
  .info-section h4{color:#9ca3af;font-size:14px;margin:1rem 0 .5rem}
  .info-section p{color:#d1d5db;margin-bottom:1rem}
  .info-section ol{color:#d1d5db;padding-left:1.5rem}
  .info-section li{margin-bottom:.5rem}
  .plot-explanations{display:grid;grid-template-columns:1fr 1fr;gap:2rem;margin:2rem 0}
  .plot-explanation{background:#0f172a;border:1px solid #1f2937;border-radius:.8rem;padding:1.5rem}
  .technical-note{background:#1e293b;border-left:3px solid #3b82f6;padding:1rem;margin:1rem 0;border-radius:0 .5rem .5rem 0}
  .technical-note ul{margin:.5rem 0;padding-left:1.5rem}
  .technical-note li{margin-bottom:.25rem}
  .usage-guide{background:#0f172a;border:1px solid #1f2937;border-radius:.8rem;padding:1.5rem;margin-top:2rem}
  .viz-panel h3{margin:0 0 .5rem;color:#e2e8f0;font-size:14px}
  .viz-svg{width:100%;height:calc(100% - 2rem)}
  .axis{color:#94a3b8;font-size:10px}
  .axis line,.axis path{stroke:#94a3b8}
  .distribution-bar{fill:#8b5cf6;opacity:0.7}
  .distribution-bar:hover{opacity:1}
  .slope-dot{fill:#22c55e;stroke:#fff;stroke-width:1}
  .hospital-label{fill:#e2e8f0;font-size:9px}
  aside h3{margin:.25rem 0 .5rem}
  .card{border:1px solid #1f2937;background:#0b1325;border-radius:.6rem;padding:.55rem;margin-bottom:.55rem}
  .card code{font-family:ui-monospace,SFMono-Regular,Menlo,monospace}
  .state{fill:#1e293b;stroke:#94a3b8;stroke-width:.6px}
  .graticule{fill:none;stroke:#334155;stroke-opacity:.35}
  .circle{fill:rgba(99,102,241,.12);stroke:#8b5cf6;stroke-width:1.5px}
  .marker-zip{fill:#f43f5e;stroke:#fff;stroke-width:1.2px}
  .marker-hosp{fill:#22c55e;stroke:#0b1325;stroke-width:1px}
  .small{font-size:12px;color:#93a4b3}
  .badge{display:inline-block;padding:.1rem .35rem;border:1px solid #334155;border-radius:.4rem;margin-left:.3rem;color:#cbd5e1}
  .price-item{border:1px solid #1f2937;border-radius:.4rem;padding:.35rem;margin-top:.35rem;transition:all 0.2s ease}
  .price-item:hover{border-color:#334155;background:rgba(15,23,42,.3)}
  .hospital-header{cursor:pointer;transition:background 0.2s ease}
  .hospital-header:hover{background:rgba(15,23,42,.5)}
  .hospital-prices{display:none;margin-top:.5rem;border-top:1px solid #1f2937;padding-top:.5rem}
  .hospital-prices.expanded{display:block}
  .toggle-indicator{float:right;font-size:16px;transition:transform 0.2s ease}
  .toggle-indicator.expanded{transform:rotate(90deg)}
  .payer-info{font-weight:bold;margin-bottom:.3rem;color:#cbd5e1}
  .price-table{width:100%;border-collapse:collapse;margin-top:.3rem;font-size:12px}
  .price-table th{background:#1f2937;color:#e2e8f0;padding:.3rem .5rem;text-align:left;border:1px solid #374151;font-weight:600}
  .price-table td{padding:.25rem .5rem;border:1px solid #374151;color:#d1d5db}
  .price-table tr:nth-child(even){background:rgba(31,41,55,.3)}
  .price-table .price-type{font-weight:500;color:#93c5fd}
  </style>
</head>
<body>
  <header>
    <label>Configuration Type:
      <select id="config-type">
        <option value="service" selected>Service</option>
        <option value="revenue-code">Revenue Code</option>
      </select>
    </label>
    <label id="service-label">
      <select id="service">
        <option value="">(Select Group)</option>
      </select>
    </label>
    <label id="procedure-label" style="display: none;">Procedure (regex or code):
      <input id="q" placeholder="e.g. (MRI|70551)|^70551$" size="28"/>
    </label>
    <label>ZIP: <input id="zip" placeholder="e.g. 27587" size="8"/></label>
    <label>Radius:
      <select id="radius">
        <option value="10">10 mi</option>
        <option value="25" selected>25 mi</option>
        <option value="50">50 mi</option>
        <option value="100">100 mi</option>
        <option value="250">250 mi</option>
        <option value="500">500+</option>
      </select>
    </label>
    <label>Payer:
      <select id="payer">
        <option value="">All Payers</option>
      </select>
    </label>
    <button id="go">Search</button>
    <span id="status"></span>
  </header>

  <main>
    <div class="map-container">
      <svg id="map" viewBox="0 0 960 600" aria-label="US map"></svg>
      <button id="reset-zoom" class="reset-zoom-btn">üîç Reset Zoom</button>
    </div>
    <aside>
      <h3 id="list-title">Hospitals (0)</h3>
      <div class="small">Shows hospitals within the radius; price hits appear under each.</div>
      <label style="display: block; margin: 0.5rem 0; font-size: 14px;">
        <input id="unit" type="checkbox" /> Show as ratio-to-Medicare
      </label>
      <div id="list"></div>
    </aside>
  </main>

  <div class="visualization-section">
    <div class="viz-container">
      <div class="viz-panel">
        <h3>Price Distribution</h3>
        <svg id="distribution-chart" class="viz-svg"></svg>
      </div>
      <div class="viz-panel">
        <h3>Hospital Price Comparison</h3>
        <svg id="slopegraph-chart" class="viz-svg"></svg>
      </div>
    </div>
  </div>

  <div class="info-section">
    <div class="info-container">
      <h2>About This Tool</h2>
      <p>The <strong>Hospital Price Finder</strong> helps you discover and compare healthcare procedure costs across hospitals within a specified radius of any ZIP code. Search by procedure codes (CPT, HCPCS) or custom patterns to find pricing transparency data from hospital charge masters.</p>
      
      <div class="plot-explanations">
        <div class="plot-explanation">
          <h3>üìä Price Distribution Chart</h3>
          <p>Shows the frequency distribution of all individual price points found for your search. This histogram displays every price entry (estimated amounts, minimum charges, maximum charges) from all matching procedures across all hospitals. Each bar represents how many procedures fall within that price range, giving you an overview of the overall pricing landscape.</p>
        </div>
        
        <div class="plot-explanation">
          <h3>üìà Hospital Price Comparison (Slope Chart)</h3>
          <p>Compares average minimum vs. maximum prices per hospital. Each colored line represents one hospital, connecting the average of all minimum prices (left) to the average of all maximum prices (right) for matching procedures. Hover over lines to see hospital names and exact values.</p>
          
          <div class="technical-note">
            <h4>üìã Data Calculation Details</h4>
            <ul>
              <li><strong>Slope Chart:</strong> Averages multiple procedures per hospital into single min/max values</li>
              <li><strong>Sidebar:</strong> Shows individual procedure records with specific min/max prices</li>
              <li><strong>Histogram:</strong> Plots every individual price point from all procedures</li>
            </ul>
            <p><em>Note: If a hospital appears in multiple matching procedures, the slope chart shows averages while the sidebar displays each individual procedure separately. This explains why slope chart values may not exactly match individual sidebar entries.</em></p>
          </div>
        </div>
      </div>
      
      <div class="usage-guide">
        <h3>üîç How to Use</h3>
        <ol>
          <li>Select a predefined service or enter a custom procedure pattern (regex supported)</li>
          <li>Enter a ZIP code and choose your search radius</li>
          <li>Optionally filter by insurance payer or view prices as ratios to Medicare rates</li>
          <li>Click search to see hospitals on the map and pricing data in the sidebar</li>
          <li>Scroll down to analyze price distributions and hospital comparisons</li>
          <li>Use the reset zoom button to return to the full map view</li>
        </ol>
      </div>
    </div>
  </div>

  <script type="module">
  import * as topojson from "https://cdn.jsdelivr.net/npm/topojson-client@3/+esm";

  // --------- CONFIG / URL HELPERS ----------
  const WIDTH = 960, HEIGHT = 600, EARTH_MI = 3958.7613;
  const ENABLE_PRICES = true;  // set false to debug map/CSV only

  // robust path resolution relative to this HTML file
  const urlFrom = (p) => p;  // Simple relative path resolution
  const DATA_ZIPS = "data/zip_centroids.csv";
  const DATA_HOSPS = "data/hospitals.csv";
  const DATA_SERVICE = "data/service_config.json";
  const DATA_RC = "data/rc_config.json";
  const DATA_CMS = "data/medicare_pricing_matched.csv";
  const jsonUrl = (relPath) => relPath.startsWith('docs/') ? relPath.substring(5) : relPath;

  // --------- ELEMENTS ----------
  const svg = d3.select("#map");
  const $q = document.getElementById("q");
  const $zip = document.getElementById("zip");
  const $radius = document.getElementById("radius");
  const $payer = document.getElementById("payer");
  const $service = document.getElementById("service");
  const $configType = document.getElementById("config-type");
  const $unit = document.getElementById("unit");
  const $go = document.getElementById("go");
  const $status = document.getElementById("status");
  const $list = document.getElementById("list");
  const $listTitle = document.getElementById("list-title");
  const setStatus = (t)=> $status.textContent = t;

  // --------- DATA MAPS ----------
  const cmsRate = new Map();
  const services = new Map();
  const revenueCodes = new Map();
  let currentConfigType = 'service';

  // --------- USER LOCATION ----------
  let userLocation = {
    latitude: null,
    longitude: null,
    zipcode: null,
    permissionGranted: false,
    permissionAsked: false
  };

  // --------- MAP ----------
  const projection = d3.geoAlbersUsa().translate([WIDTH/2, HEIGHT/2]).scale(1200);
  const path = d3.geoPath(projection);
  const gBase = svg.append("g");
  const gOverlay = svg.append("g");
  const zoom = d3.zoom().scaleExtent([1, 20])
    .filter(event => {
      // Disable mouse wheel zoom, but allow other interactions (drag, programmatic)
      return !event.ctrlKey && event.type !== 'wheel';
    })
    .on("zoom", (ev) => {
      gBase.attr("transform", ev.transform);
      gOverlay.attr("transform", ev.transform);
      gOverlay.selectAll(".marker-zip").attr("r", 4/ev.transform.k);
      gOverlay.selectAll(".marker-hosp").attr("r", 3.5/ev.transform.k);
    });
  svg.call(zoom);

  // Reset zoom button functionality
  document.getElementById('reset-zoom').addEventListener('click', () => {
    svg.transition().duration(800)
       .call(zoom.transform, d3.zoomIdentity);
  });

  const circlePath = gOverlay.append("path").attr("class","circle").style("display","none");
  const zipMarker  = gOverlay.append("circle").attr("class","marker-zip").attr("r",4).style("display","none");
  const hospLayer  = gOverlay.append("g").attr("class","hospitals");

  const miles2deg = (mi)=> mi/69;
  const gcMiles = (aLonLat, bLonLat)=> d3.geoDistance(aLonLat, bLonLat) * EARTH_MI;
  function zoomTo(feature, pad=20){
    const [[x0,y0],[x1,y1]] = path.bounds(feature);
    const dx=x1-x0, dy=y1-y0, cx=(x0+x1)/2, cy=(y0+y1)/2;
    const scale = Math.max(1, Math.min(20, 0.9/Math.max(dx/(WIDTH-2*pad), dy/(HEIGHT-2*pad))));
    const translate = [WIDTH/2 - scale*cx, HEIGHT/2 - scale*cy];
    svg.transition().duration(800)
       .call(zoom.transform, d3.zoomIdentity.translate(translate[0], translate[1]).scale(scale));
  }

  // --------- GEOLOCATION FUNCTIONS ----------
  async function requestUserLocation() {
    if (!navigator.geolocation) {
      console.warn('Geolocation is not supported by this browser.');
      return false;
    }

    if (userLocation.permissionAsked) {
      return userLocation.permissionGranted;
    }

    userLocation.permissionAsked = true;

    try {
      const position = await new Promise((resolve, reject) => {
        navigator.geolocation.getCurrentPosition(resolve, reject, {
          enableHighAccuracy: true,
          timeout: 10000,
          maximumAge: 60000
        });
      });

      userLocation.latitude = position.coords.latitude;
      userLocation.longitude = position.coords.longitude;
      userLocation.permissionGranted = true;

      // Try to get ZIP code from coordinates
      const zipcode = await getZipcodeFromCoords(userLocation.latitude, userLocation.longitude);
      if (zipcode) {
        userLocation.zipcode = zipcode;
        // Auto-fill the ZIP input if it's empty
        if (!$zip.value) {
          $zip.value = zipcode;
          setStatus(`Location detected. Auto-filled ZIP code: ${zipcode}`);
        }
      }

      return true;
    } catch (error) {
      console.warn('Error getting user location:', error);
      userLocation.permissionGranted = false;
      return false;
    }
  }

  async function getZipcodeFromCoords(lat, lon) {
    try {
      // Use a free geocoding service (Nominatim is free and reliable)
      const response = await fetch(`https://nominatim.openstreetmap.org/reverse?format=json&lat=${lat}&lon=${lon}&zoom=18&addressdetails=1`);
      
      if (!response.ok) {
        throw new Error(`Geocoding failed: ${response.status}`);
      }

      const data = await response.json();
      
      // Extract ZIP code from the response
      const zipcode = data.address?.postcode;
      
      if (zipcode) {
        // Ensure it's a 5-digit US ZIP code
        const cleanZip = zipcode.replace(/\D/g, '').slice(0, 5);
        if (cleanZip.length === 5) {
          return cleanZip;
        }
      }
      
      console.warn('Could not extract valid ZIP code from geocoding response');
      return null;
    } catch (error) {
      console.warn('Error in reverse geocoding:', error);
      return null;
    }
  }

  function showLocationPrompt() {
    // Create a modal-style prompt
    const promptDiv = document.createElement('div');
    promptDiv.style.cssText = `
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.8);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 10000;
    `;
    
    promptDiv.innerHTML = `
      <div style="
        background: #1f2937;
        color: #e2e8f0;
        padding: 2rem;
        border-radius: 0.5rem;
        max-width: 400px;
        text-align: center;
        border: 1px solid #374151;
      ">
        <h3 style="margin-top: 0; color: #cbd5e1;">üìç Location Access</h3>
        <p style="margin-bottom: 1.5rem; line-height: 1.5;">
          Would you like to share your location to automatically detect your ZIP code?
          This will help you quickly find nearby hospitals.
        </p>
        <div style="display: flex; gap: 1rem; justify-content: center;">
          <button id="allow-location" style="
            background: #059669;
            color: white;
            border: none;
            padding: 0.75rem 1.5rem;
            border-radius: 0.375rem;
            cursor: pointer;
            font-weight: 500;
          ">Allow Location</button>
          <button id="deny-location" style="
            background: #6b7280;
            color: white;
            border: none;
            padding: 0.75rem 1.5rem;
            border-radius: 0.375rem;
            cursor: pointer;
            font-weight: 500;
          ">No Thanks</button>
        </div>
      </div>
    `;

    document.body.appendChild(promptDiv);

    // Handle user choice
    document.getElementById('allow-location').addEventListener('click', async () => {
      document.body.removeChild(promptDiv);
      setStatus('Requesting location access...');
      await requestUserLocation();
    });

    document.getElementById('deny-location').addEventListener('click', () => {
      document.body.removeChild(promptDiv);
      userLocation.permissionAsked = true;
      userLocation.permissionGranted = false;
      setStatus('Location access denied. You can manually enter a ZIP code.');
    });
  }

  // 1) BASEMAP FIRST (isolated)
  try {
    const graticule = d3.geoGraticule10();
    gBase.append("path").attr("class","graticule").attr("d", path(graticule));
    const res = await fetch("https://cdn.jsdelivr.net/npm/us-atlas@3/states-10m.json");
    if (!res.ok) throw new Error(`us-atlas fetch failed: ${res.status}`);
    const us = await res.json();
    const states = topojson.feature(us, us.objects.states).features;
    gBase.selectAll("path.state").data(states).join("path").attr("class","state").attr("d", path);
  } catch (err) {
    console.error("Basemap error:", err);
    setStatus("Basemap failed to load. See console.");
  }

  // 2) SMALL CSVs
  let ZIP = new Map(), hospitals = [];
  try {
    const zipRows = await d3.csv(DATA_ZIPS, d3.autoType);
    ZIP = new Map(zipRows.map(d=>[String(d.zip).padStart(5,'0'), [d.lat, d.lon]]));
  } catch (e) {
    console.warn("zip_centroids.csv failed:", e);
    setStatus("ZIP data missing.");
  }
  try {
    hospitals = await d3.csv(DATA_HOSPS, d3.autoType);
    hospitals.forEach(d => { 
      d.ll = [d.lon, d.lat]; 
      // Use json_path from CSV
      d.json_path = d.json_path || '';
    });

  } catch (e) {
    console.warn("hospitals.csv failed:", e);
    setStatus("Hospitals index missing.");
  }

  // 3) Load service configuration and CMS rates
  try {
    const svcCfg = await fetch(DATA_SERVICE).then(r=>r.json());
    Object.entries(svcCfg).forEach(([name, obj])=>{
      services.set(name, new RegExp(obj.pattern, 'i'));
    });
  } catch (e) {
    console.warn("service_config.json failed:", e);
  }

  // Load revenue code configuration
  try {
    const rcCfg = await fetch(DATA_RC).then(r=>r.json());
    Object.entries(rcCfg).forEach(([name, obj])=>{
      revenueCodes.set(name, new RegExp(obj.pattern, 'i'));
    });
  } catch (e) {
    console.warn("rc_config.json failed:", e);
  }

  // Function to populate dropdown based on configuration type
  function populateServiceDropdown(configType) {
    // Clear existing options except the first one
    $service.innerHTML = '<option value="">(Select Group)</option>';
    
    const configMap = configType === 'service' ? services : revenueCodes;
    
    configMap.forEach((regex, name) => {
      const opt = document.createElement('option'); 
      opt.value = name; 
      opt.textContent = name;
      $service.appendChild(opt);
    });
    
    // Add Custom Pattern option at the end
    const customOpt = document.createElement('option');
    customOpt.value = 'custom';
    customOpt.textContent = 'Custom Pattern';
    $service.appendChild(customOpt);
  }

  // Initialize with service configuration
  populateServiceDropdown('service');

  // Add event listener for configuration type change
  $configType.addEventListener('change', function() {
    currentConfigType = this.value;
    populateServiceDropdown(currentConfigType);
    
    // Update the service label
    // const serviceLabel = document.getElementById('service-label');
    // serviceLabel.childNodes[0].textContent = currentConfigType === 'service' ? 'Service:' : 'Revenue Code:';
    
    // Reset service selection
    $service.value = '';
    // Hide procedure input
    document.getElementById('procedure-label').style.display = 'none';
    $q.value = '';
  });

  try {
    const cmsRows = await d3.csv(DATA_CMS, d3.autoType);
    cmsRows.forEach(r => cmsRate.set(String(r.code), +r.price || 0));
  } catch (e) {
    console.warn("medicare_pricing_matched.csv failed:", e);
  }

  // 4) JSON Loading Cache
  const jsonCache = new Map(); // Cache loaded JSON files

  // --------- HELPER FUNCTIONS ----------
  // Helper: choose a usable $ amount per record
  const amountOf = r => +r.estimated_amount || +r.standard_charge_dollar || +r.standard_charge_gross
                    || +r.standard_charge_min || +r.standard_charge_max || 0;

  // Helper: format price display - returns object with price and ratio
  const formatPrice = (amount, code) => {
    if (!amount || amount === 0) return { price: "N/A", ratio: "N/A" };
    
    const price = `$${Number(amount).toLocaleString()}`;
    let ratio = "N/A";
    
    if (code) {
      const medicareRate = cmsRate.get(String(code)) || 0;
      if (medicareRate > 0) {
        ratio = `${(amount / medicareRate).toFixed(2)}x`;
      }
    }
    
    return { price, ratio };
  };

  // Helper: get the appropriate code field based on configuration type
  const getCodeField = (record) => {
    // Always use 'code' field for display and Medicare ratio calculations
    return record.code || '';
  };

  // Helper: get the search code field based on configuration type
  const getSearchCodeField = () => {
    return currentConfigType === 'service' ? 'code' : 'rc_code';
  };

  // Helper: generate price table HTML
  const generatePriceTable = (record) => {
    const showRatio = $unit.checked;
    const code = getCodeField(record);
    const priceTypes = [];
    
    if (record.estimated_amount != null) {
      const formatted = formatPrice(record.estimated_amount, code);
      priceTypes.push({ type: "Estimate", price: formatted.price, ratio: formatted.ratio });
    }
    if (record.standard_charge_min != null) {
      const formatted = formatPrice(record.standard_charge_min, code);
      priceTypes.push({ type: "Minimum", price: formatted.price, ratio: formatted.ratio });
    }
    if (record.standard_charge_max != null) {
      const formatted = formatPrice(record.standard_charge_max, code);
      priceTypes.push({ type: "Maximum", price: formatted.price, ratio: formatted.ratio });
    }
    
    if (priceTypes.length === 0) return "<div class='small'>No pricing data available</div>";
    
    return `
      <table class="price-table">
        <thead>
          <tr>
            <th></th>
            <th>Price</th>
            ${showRatio ? '<th>Medicare Ratio</th>' : ''}
          </tr>
        </thead>
        <tbody>
          ${priceTypes.map(pt => `
            <tr>
              <td class="price-type">${pt.type}</td>
              <td>${pt.price}</td>
              ${showRatio ? `<td>${pt.ratio}</td>` : ''}
            </tr>
          `).join('')}
        </tbody>
      </table>
    `;
  };

  // --------- VISUALIZATION FUNCTIONS ----------
  const distributionSvg = d3.select("#distribution-chart");
  const slopegraphSvg = d3.select("#slopegraph-chart");

  // Create distribution histogram
  function createDistributionChart(allHits) {
    distributionSvg.selectAll("*").remove();
    
    if (!allHits || allHits.length === 0) {
      distributionSvg.append("text")
        .attr("x", "50%")
        .attr("y", "50%")
        .attr("text-anchor", "middle")
        .attr("fill", "#94a3b8")
        .text("No data to display");
      return;
    }

    const margin = {top: 20, right: 30, bottom: 40, left: 60};
    const containerWidth = parseInt(distributionSvg.style("width")) || 400;
    const containerHeight = parseInt(distributionSvg.style("height")) || 300;
    const width = containerWidth - margin.left - margin.right;
    const height = containerHeight - margin.top - margin.bottom;

    const g = distributionSvg.append("g")
      .attr("transform", `translate(${margin.left},${margin.top})`);

    // Get all price values
    const prices = [];
    allHits.forEach(hit => {
      if (hit.estimated_amount != null) prices.push(+hit.estimated_amount);
      if (hit.standard_charge_min != null) prices.push(+hit.standard_charge_min);
      if (hit.standard_charge_max != null) prices.push(+hit.standard_charge_max);
    });

    if (prices.length === 0) {
      g.append("text")
        .attr("x", width/2)
        .attr("y", height/2)
        .attr("text-anchor", "middle")
        .attr("fill", "#94a3b8")
        .text("No price data available");
      return;
    }

    // Create histogram
    const xScale = d3.scaleLinear()
      .domain(d3.extent(prices))
      .range([0, width]);

    const histogram = d3.histogram()
      .value(d => d)
      .domain(xScale.domain())
      .thresholds(Math.min(20, Math.ceil(Math.sqrt(prices.length))));

    const bins = histogram(prices);

    const yScale = d3.scaleLinear()
      .domain([0, d3.max(bins, d => d.length)])
      .range([height, 0]);

    // Add bars
    g.selectAll("rect")
      .data(bins)
      .join("rect")
      .attr("class", "distribution-bar")
      .attr("x", d => xScale(d.x0))
      .attr("width", d => Math.max(0, xScale(d.x1) - xScale(d.x0) - 1))
      .attr("y", d => yScale(d.length))
      .attr("height", d => height - yScale(d.length))
      .append("title")
      .text(d => `$${d.x0.toLocaleString()} - $${d.x1.toLocaleString()}: ${d.length} prices`);

    // Add axes
    g.append("g")
      .attr("class", "axis")
      .attr("transform", `translate(0,${height})`)
      .call(d3.axisBottom(xScale).tickFormat(d => `$${d/1000}k`));

    g.append("g")
      .attr("class", "axis")
      .call(d3.axisLeft(yScale));

    // Add labels
    g.append("text")
      .attr("x", width/2)
      .attr("y", height + 35)
      .attr("text-anchor", "middle")
      .attr("fill", "#e2e8f0")
      .style("font-size", "11px")
      .text($unit.checked ? "Price Distribution (All Types)" : "Price Distribution");

    g.append("text")
      .attr("transform", "rotate(-90)")
      .attr("y", -40)
      .attr("x", -height/2)
      .attr("text-anchor", "middle")
      .attr("fill", "#e2e8f0")
      .style("font-size", "11px")
      .text("Count");
  }

  // Create slopegraph
  function createSlopegraph(hospitalData) {
    slopegraphSvg.selectAll("*").remove();
    
    if (!hospitalData || hospitalData.length === 0) {
      slopegraphSvg.append("text")
        .attr("x", "50%")
        .attr("y", "50%")
        .attr("text-anchor", "middle")
        .attr("fill", "#94a3b8")
        .text("No data to display");
      return;
    }

    const margin = {top: 20, right: 80, bottom: 40, left: 80};
    const containerWidth = parseInt(slopegraphSvg.style("width")) || 400;
    const containerHeight = parseInt(slopegraphSvg.style("height")) || 300;
    const width = containerWidth - margin.left - margin.right;
    const height = containerHeight - margin.top - margin.bottom;

    const g = slopegraphSvg.append("g")
      .attr("transform", `translate(${margin.left},${margin.top})`);

    // Prepare data - get hospitals with both min and max prices
    const slopeData = hospitalData.filter(h => {
      const hits = h.hits || [];
      const minPrices = hits.filter(hit => hit.standard_charge_min != null);
      const maxPrices = hits.filter(hit => hit.standard_charge_max != null);
      return minPrices.length > 0 && maxPrices.length > 0;
    }).slice(0, 10); // Limit to 10 hospitals for readability

    if (slopeData.length === 0) {
      g.append("text")
        .attr("x", width/2)
        .attr("y", height/2)
        .attr("text-anchor", "middle")
        .attr("fill", "#94a3b8")
        .text("No min/max price data available");
      return;
    }

    // Calculate averages for each hospital
    const processedData = slopeData.map(h => {
      const hits = h.hits || [];
      const minPrices = hits.filter(hit => hit.standard_charge_min != null).map(hit => +hit.standard_charge_min);
      const maxPrices = hits.filter(hit => hit.standard_charge_max != null).map(hit => +hit.standard_charge_max);
      
      return {
        hospital: h.name,
        minAvg: d3.mean(minPrices),
        maxAvg: d3.mean(maxPrices)
      };
    }).filter(d => d.minAvg != null && d.maxAvg != null);

    if (processedData.length === 0) return;

    // Scales
    const allValues = processedData.flatMap(d => [d.minAvg, d.maxAvg]);
    const yScale = d3.scaleLinear()
      .domain(d3.extent(allValues))
      .range([height, 0]);

    // Color scale for different hospitals
    const colorScale = d3.scaleOrdinal()
      .domain(processedData.map(d => d.hospital))
      .range(d3.schemeCategory10);

    const xPositions = [0, width];

    // Create tooltip div for hospital names
    const tooltip = d3.select("body").selectAll(".slope-tooltip").data([0]).join("div")
      .attr("class", "slope-tooltip")
      .style("position", "absolute")
      .style("background", "rgba(15, 23, 42, 0.95)")
      .style("color", "#e2e8f0")
      .style("padding", "8px 12px")
      .style("border-radius", "6px")
      .style("border", "1px solid #374151")
      .style("font-size", "12px")
      .style("pointer-events", "none")
      .style("opacity", 0)
      .style("z-index", 1000);

    // Draw lines with hover functionality
    g.selectAll(".slope-line")
      .data(processedData)
      .join("path")
      .attr("d", d => d3.line()([[xPositions[0], yScale(d.minAvg)], [xPositions[1], yScale(d.maxAvg)]]))
      .style("stroke", d => colorScale(d.hospital))
      .style("stroke-width", "3px")
      .style("fill", "none")
      .style("opacity", 0.7)
      .style("cursor", "pointer")
      .on("mouseover", function(event, d) {
        d3.select(this).style("opacity", 1).style("stroke-width", "4px");
        tooltip
          .style("opacity", 1)
          .html(`<strong>${d.hospital}</strong><br/>Min: $${Math.round(d.minAvg).toLocaleString()}<br/>Max: $${Math.round(d.maxAvg).toLocaleString()}`)
          .style("left", (event.pageX + 10) + "px")
          .style("top", (event.pageY - 10) + "px");
      })
      .on("mousemove", function(event) {
        tooltip
          .style("left", (event.pageX + 10) + "px")
          .style("top", (event.pageY - 10) + "px");
      })
      .on("mouseout", function() {
        d3.select(this).style("opacity", 0.7).style("stroke-width", "3px");
        tooltip.style("opacity", 0);
      });

    // Draw dots
    g.selectAll(".slope-dot-min")
      .data(processedData)
      .join("circle")
      .attr("class", "slope-dot")
      .attr("cx", xPositions[0])
      .attr("cy", d => yScale(d.minAvg))
      .attr("r", 3)
      .attr("fill", d => colorScale(d.hospital))
      .attr("stroke", "#fff")
      .attr("stroke-width", 1);

    g.selectAll(".slope-dot-max")
      .data(processedData)
      .join("circle")
      .attr("class", "slope-dot")
      .attr("cx", xPositions[1])
      .attr("cy", d => yScale(d.maxAvg))
      .attr("r", 3)
      .attr("fill", d => colorScale(d.hospital))
      .attr("stroke", "#fff")
      .attr("stroke-width", 1);

    // Add labels
    g.append("text")
      .attr("x", xPositions[0])
      .attr("y", -10)
      .attr("text-anchor", "middle")
      .attr("fill", "#e2e8f0")
      .style("font-size", "11px")
      .text("Min Price");

    g.append("text")
      .attr("x", xPositions[1])
      .attr("y", -10)
      .attr("text-anchor", "middle")
      .attr("fill", "#e2e8f0")
      .style("font-size", "11px")
      .text("Max Price");

    // Add y-axis with better formatting
    const yAxisFormat = d => {
      if (d >= 1000000) return `$${(d/1000000).toFixed(1)}M`;
      if (d >= 1000) return `$${(d/1000).toFixed(0)}k`;
      return `$${d.toFixed(0)}`;
    };
    
    g.append("g")
      .attr("class", "axis")
      .call(d3.axisLeft(yScale).tickFormat(yAxisFormat));
  }

  // Update all visualizations
  function updateVisualizations(hospitalList, hitsById) {
    // Prepare data
    const allHits = [];
    const hospitalData = hospitalList.map(h => {
      const hits = hitsById.get(h.id) || [];
      allHits.push(...hits);
      return { ...h, hits };
    });

    // Update charts
    createDistributionChart(allHits);
    createSlopegraph(hospitalData);
  }

  // Service selector change handler
  $service.addEventListener('change', () => {
    const procedureLabel = document.getElementById('procedure-label');
    if ($service.value === 'custom') {
      // Show search bar for custom pattern
      procedureLabel.style.display = '';
      $q.placeholder = "e.g. (MRI|70551)|^70551$";
      $q.value = '';
    } else if ($service.value) {
      // Hide search bar for predefined services
      procedureLabel.style.display = 'none';
      $q.value = ''; // Clear custom pattern when service is selected
    } else {
      // Hide search bar when no selection
      procedureLabel.style.display = 'none';
      $q.value = '';
    }
  });

  setStatus("Ready to search JSON price files.");

  // Show location prompt after app is ready
  setTimeout(() => {
    if (!userLocation.permissionAsked) {
      showLocationPrompt();
    }
  }, 1000); // Small delay to let the page fully load

  function renderHospitals(hlist, hitsById){
    $list.innerHTML = "";
    $listTitle.textContent = `Hospitals (${hlist.length})`;
    const pts = hospLayer.selectAll("circle.marker-hosp").data(hlist, d=>d.id);
    pts.join(
      en => en.append("circle").attr("class","marker-hosp").attr("r",3.5)
                .attr("cx", d => projection(d.ll)?.[0] ?? -9999)
                .attr("cy", d => projection(d.ll)?.[1] ?? -9999),
      up => up.attr("cx", d => projection(d.ll)?.[0] ?? -9999)
              .attr("cy", d => projection(d.ll)?.[1] ?? -9999),
      ex => ex.remove()
    );
    for(const h of hlist){
      const div = document.createElement("div"); div.className = "card";
      const hits = hitsById.get(h.id) || [];
      const hospitalId = `hospital-${h.id}`;
      
      div.innerHTML = `
        <div class="hospital-header" onclick="toggleHospitalPrices('${hospitalId}')">
          <div>
            <strong>${h.name}</strong> 
            <span class="badge">${h.state ?? ""}</span>
            <span class="toggle-indicator" id="toggle-${hospitalId}">‚ñ∂</span>
          </div>
          <div class="small">${h.zip ?? ""} ¬∑ ${h.lat?.toFixed?.(4) ?? ""}, ${h.lon?.toFixed?.(4) ?? ""}</div>
          ${hits.length ? `<div style="margin-top:.4rem"><strong>${hits.length}</strong> match${hits.length>1?"es":""} found - click to view</div>` : `<div class="small" style="margin-top:.4rem">No matches in file</div>`}
        </div>
        ${hits.length ? `
          <div class="hospital-prices" id="${hospitalId}">
            ${hits.slice(0,hits.length).map(r => `
              <div class="price-item">
                ${r.payer_name || r.plan_name ? `
                  <div class="payer-info">
                    ${r.payer_name ? r.payer_name : ""}${r.payer_name && r.plan_name ? " - " : ""}${r.plan_name ? r.plan_name : ""}
                  </div>
                ` : ""}
                <div style="margin-bottom:.4rem"><code>${getCodeField(r)}</code> ‚Äî ${r.description ?? ""}</div>
                ${generatePriceTable(r)}
              </div>
            `).join("")}
          </div>
        ` : ""}
      `;
      
      // Add click handler for map zoom (only on hospital name area, not the toggle)
      const hospitalNameArea = div.querySelector('.hospital-header > div:first-child strong');
      if (hospitalNameArea) {
        hospitalNameArea.style.cursor = 'pointer';
        hospitalNameArea.onclick = (e) => {
          e.stopPropagation(); // Prevent triggering the toggle
          const p = projection(h.ll); if(!p) return;
          svg.transition().duration(600)
            .call(zoom.transform, d3.zoomIdentity.translate(WIDTH/2 - p[0]*6, HEIGHT/2 - p[1]*6).scale(6));
        };
      }
      
      $list.appendChild(div);
    }
    
    // Store current data and update visualizations
    currentHospitalList = hlist;
    currentHitsById = hitsById;
    updateVisualizations(hlist, hitsById);
  }

  async function loadHospitalJSON(jsonPath) {
    if (!jsonPath) return [];
    
    try {
      // Check cache first
      if (jsonCache.has(jsonPath)) {
        return jsonCache.get(jsonPath);
      }
      
      // Load JSON file
      const url = jsonUrl(jsonPath);
      const response = await fetch(url);
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }
      
      const text = await response.text();
      // Parse JSON lines format (each line is a separate JSON object)
      const jsonData = text.trim().split('\n').map(line => {
        try {
          return JSON.parse(line);
        } catch (e) {
          console.warn("Failed to parse JSON line:", line.substring(0, 100));
          return null;
        }
      }).filter(obj => obj !== null);
      
      // Cache the parsed data
      jsonCache.set(jsonPath, jsonData);
      return jsonData;
      
    } catch(e) {
      console.warn("JSON loading failed:", jsonPath, e);
      return [];
    }
  }

  async function queryHospitalJSON(jsonPath, regexOrCode, selectedPayer = null){
    if (!jsonPath || !regexOrCode) return [];
    
    try {
      const jsonData = await loadHospitalJSON(jsonPath);
      
      // Create regex for searching
      const regex = new RegExp(regexOrCode, 'i');
      
      // Determine which code field to search based on configuration type
      const codeField = getSearchCodeField();
      
      // Search through descriptions and codes
      let matches = jsonData.filter(record => {
        const description = record.description || '';
        const code = record[codeField] || '';
        const matchesRegex = regex.test(description) || regex.test(code);
        const matchesPayer = !selectedPayer || (record.payer_name && record.payer_name === selectedPayer);
        return matchesRegex && matchesPayer;
      }).slice(0, 50); // Limit to 50 results
      
      // Sort by estimated_amount if available
      matches.sort((a, b) => {
        const aAmount = parseFloat(a.estimated_amount) || 0;
        const bAmount = parseFloat(b.estimated_amount) || 0;
        return aAmount - bAmount;
      });
      
      return matches;
      
    } catch(e){
      console.warn("JSON query failed:", jsonPath, e);
      return [];
    }
  }

  async function getUniquePayers(hospitalList) {
    const payerSet = new Set();
    
    // Load all JSON files for hospitals in the list and extract unique payers
    const promises = hospitalList.map(async (hospital) => {
      if (!hospital.json_path) return;
      
      try {
        const jsonData = await loadHospitalJSON(hospital.json_path);
        jsonData.forEach(record => {
          if (record.payer_name && record.payer_name.trim()) {
            payerSet.add(record.payer_name.trim());
          }
        });
      } catch (e) {
        console.warn("Failed to load payers from:", hospital.json_path);
      }
    });
    
    await Promise.all(promises);
    
    // Convert set to sorted array
    return Array.from(payerSet).sort();
  }

  function populatePayerDropdown(payers) {
    // Save the currently selected payer
    const currentSelection = $payer.value;
    
    // Clear existing options except "All Payers"
    $payer.innerHTML = '<option value="">All Payers</option>';
    
    // Add unique payers
    payers.forEach(payer => {
      const option = document.createElement('option');
      option.value = payer;
      option.textContent = payer;
      $payer.appendChild(option);
    });
    
    // Restore the previous selection if it still exists in the new list
    if (currentSelection && payers.includes(currentSelection)) {
      $payer.value = currentSelection;
    }
  }

  async function go(){
    const rawZip = ($zip.value||"").trim();
    const zip = rawZip.padStart(5,'0').slice(-5);
    const miles = +$radius.value;
    const svcName = $service.value;
    const q = ($q.value||"").trim();
    const selectedPayer = $payer.value || null;
    
    // Get the search pattern - either from service or custom query
    let searchPattern = '';
    const configMap = currentConfigType === 'service' ? services : revenueCodes;
    
    if (svcName && svcName !== 'custom' && configMap.has(svcName)) {
      const svcRegex = configMap.get(svcName);
      searchPattern = svcRegex.source; // Get the regex pattern string
    } else if (svcName === 'custom' && q) {
      searchPattern = q;
    }

    if(!ZIP.has(zip)){ setStatus(`ZIP ${zip} not found.`); return; }
    if(!hospitals.length){ setStatus("No hospitals index loaded."); return; }

    const [lat,lon] = ZIP.get(zip); const center = [lon, lat];
    
    let nearby;
    if (miles >= 500) {
      // 500+ mode: show all hospitals, no circle, no zoom
      circlePath.style("display", "none");
      nearby = hospitals.filter(h => isFinite(h.lon) && isFinite(h.lat));
      const p = projection(center); if(p) zipMarker.attr("cx", p[0]).attr("cy", p[1]).style("display", null);
      setStatus(`Showing all ${nearby.length} hospitals. Loading payers...`);
    } else {
      // Normal radius mode
      const circle = d3.geoCircle().center(center).radius(miles2deg(miles))();
      circlePath.datum(circle).attr("d", path).style("display", null);
      const p = projection(center); if(p) zipMarker.attr("cx", p[0]).attr("cy", p[1]).style("display", null);
      zoomTo(circle);
      nearby = hospitals.filter(h => isFinite(h.lon) && isFinite(h.lat) && gcMiles(center, h.ll) <= miles);
      setStatus(`Found ${nearby.length} hospitals within ${miles} mi. Loading payers...`);
    }

    // Load unique payers from hospitals in radius
    try {
      const uniquePayers = await getUniquePayers(nearby);
      populatePayerDropdown(uniquePayers);
      const searchDesc = svcName || q;
      const statusMsg = miles >= 500 
        ? `Showing all ${nearby.length} hospitals. ${searchDesc ? "Querying prices..." : "(select a service or enter a procedure to search prices)"}`
        : `Found ${nearby.length} hospitals within ${miles} mi. ${searchDesc ? "Querying prices..." : "(select a service or enter a procedure to search prices)"}`;
      setStatus(statusMsg);
    } catch (e) {
      console.warn("Failed to load payers:", e);
      const searchDesc = svcName || q;
      const statusMsg = miles >= 500 
        ? `Showing all ${nearby.length} hospitals. ${searchDesc ? "Querying prices..." : "(select a service or enter a procedure to search prices)"}`
        : `Found ${nearby.length} hospitals within ${miles} mi. ${searchDesc ? "Querying prices..." : "(select a service or enter a procedure to search prices)"}`;
      setStatus(statusMsg);
    }

    const hitsById = new Map();
    const pool = 4; let i = 0;
    async function worker(){
      while(i < nearby.length){
        const h = nearby[i++];
        const hits = (ENABLE_PRICES && searchPattern && h.json_path) ? await queryHospitalJSON(h.json_path, searchPattern, selectedPayer) : [];
        hitsById.set(h.id, hits);
      }
    }
    await Promise.all(Array.from({length: pool}, worker));
    renderHospitals(nearby, hitsById);
    const searchDesc = svcName || q;
    const doneMsg = miles >= 500 
      ? `Done. All ${nearby.length} hospitals searched${searchDesc ? ` for "${searchDesc}"` : ""}.`
      : `Done. ${nearby.length} hospitals searched${searchDesc ? ` for "${searchDesc}"` : ""}.`;
    setStatus(doneMsg);
  }

  // Toggle function for hospital price display
  window.toggleHospitalPrices = (hospitalId) => {
    const pricesDiv = document.getElementById(hospitalId);
    const toggleIndicator = document.getElementById(`toggle-${hospitalId}`);
    
    if (pricesDiv && toggleIndicator) {
      const isExpanded = pricesDiv.classList.contains('expanded');
      
      if (isExpanded) {
        pricesDiv.classList.remove('expanded');
        toggleIndicator.classList.remove('expanded');
        toggleIndicator.textContent = '‚ñ∂';
      } else {
        pricesDiv.classList.add('expanded');
        toggleIndicator.classList.add('expanded');
        toggleIndicator.textContent = '‚ñº';
      }
    }
  };

  // Store current data for visualization updates
  let currentHospitalList = [];
  let currentHitsById = new Map();

  $go.addEventListener("click", go);
  $zip.addEventListener("keydown", e => { if(e.key==="Enter") go(); });
  $radius.addEventListener("change", go);
  $payer.addEventListener("change", go);
  $service.addEventListener("change", go);
  $unit.addEventListener("change", () => {
    go(); // This will refresh both tables and visualizations
  });
  </script>
</body>
</html>